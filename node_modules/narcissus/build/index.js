'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inject = inject;
exports.startStatic = startStatic;
exports.stopStatic = stopStatic;
exports.rehydrate = rehydrate;

var _murmurhash = require('./murmurhash');

var _murmurhash2 = _interopRequireDefault(_murmurhash);

var _generate = require('./generate');

var _generate2 = _interopRequireDefault(_generate);

var _injectIntoStyleTag = require('./injectIntoStyleTag');

var _injectIntoStyleTag2 = _interopRequireDefault(_injectIntoStyleTag);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// An object that keeps track of whether a style has already been injected
var alreadyInjected = {};

// When true, injects do not go to the document, instead, they are stored in a
// buffer and can be extracted
var isStatic = false;
var staticBuffer = '';
var staticBufferClassNames = [];

// It has been suggested tht hashObject takes too long
// On a somewhat complex object
// {a: 'a', b: 'b', c: 'c', d: 'd', e: 'e', f: {a: 'a', b: 'b', c: 'c'}}
// 10 ** 4 operations takes ~30ms
// This is acceptable so far

// const hashObject = (object) => {
//   if (object['@@narcissus_already_hashed']) {
//     return object['@@narcissus_already_hashed'];
//   }
//   const hash = murmurhash(JSON.stringify(object));
//   object['@@narcissus_already_hashed'] = hash;
//   asap(() => {
//     delete object['@@narcissus_already_hashed'];
//     if (hash !== murmurhash(JSON.stringify(object))) {
//       console.warn('hashObject has cached an object\'s hash, but the hash is not the same anymore, so you have mutated the object passed in');
//     }
//     object['@@narcissus_already_hashed'] = hash;
//   });
//   return hash;
// };

var hashObject = function hashObject(object) {
  return (0, _murmurhash2.default)(JSON.stringify(object));
};

/**
 * Inside a React render function, this might look like...
 * return <div className={inject({ backgroundColor: 'blue' })}/>;
 *
 * Takes an object, and returns a class name
 */
function inject(object) {
  if (!object) {
    console.error('[narcissus] you are trying to inject a non object');
    return '';
  }

  var hash = hashObject(object);

  // The returned className cannot start with a number!
  var className = 'narcissus_' + hash;

  if (alreadyInjected[className]) {
    return className;
  }

  var generatedCSS = (0, _generate2.default)('.' + className, object);

  if (isStatic) {
    staticBuffer += generatedCSS;
    staticBufferClassNames.push(className);
  } else {
    (0, _injectIntoStyleTag2.default)(generatedCSS);
    alreadyInjected[className] = true;
  }

  return className;
}

/**
 * Start the static rendering process
 */
function startStatic() {
  isStatic = true;
}

/**
 * This is not using jsdoc properly is it
 * Returns a tuple containing [ css, classNames ]
 * css is the string that should be injected into the head
 * classNames is an array of classNames that have been used (use with rehydrate to be more efficient)
 */
function stopStatic() {
  isStatic = false;

  var ret = [staticBuffer, staticBufferClassNames];

  // Reset the buffers
  staticBuffer = '';
  staticBufferClassNames = [];

  return ret;
}

/**
 * Takes an array of classnames, and marks them as already injected
 * @param {Array<String>} classNames
 */
function rehydrate(classNames) {
  classNames.forEach(function (className) {
    alreadyInjected[className] = true;
  });
}