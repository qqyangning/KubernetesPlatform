'use strict';

var React = require('react');
var ReactDOM = require('react-dom');
var cloneElement = React.cloneElement;
var assign = require('object-assign');
var classNames = require('classnames');
var ClassNameMixin = require('./mixins/ClassNameMixin');
var isInViewport = require('./utils/isInViewport');
var Events = require('./utils/Events');
var TransitionEvents = require('./utils/TransitionEvents');
var requestAnimationFrame = require('./utils/requestAnimationFrame');
var debounce = require('./utils/debounce');
var canUseDOM = require('./utils/canUseDOM');
var domUtils = require('./utils/domUtils');

var ScrollSpy = React.createClass({
  displayName: 'ScrollSpy',

  mixins: [ClassNameMixin],

  propTypes: {
    animation: React.PropTypes.string,
    delay: React.PropTypes.number,
    repeat: React.PropTypes.bool,
    // container which has scrollbar
    container: React.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      animation: 'fade',
      delay: 0,
      repeat: false
    };
  },

  getInitialState: function getInitialState() {
    return {
      inViewport: false
    };
  },

  componentDidMount: function componentDidMount() {
    if (canUseDOM) {
      this.checkRAF();

      var node = ReactDOM.findDOMNode(this);
      var doc = domUtils.ownerDocument(node);
      // var scrollContainer = ReactDOM.findDOMNode(this.props.container || doc.body);
      var debounced = debounce(this.checkRAF, 100).bind(this);

      this._scrollListener = Events.on(doc, 'scroll', debounced);
      this._resizeListener = Events.on(window, 'resize', debounced);
      this._orientationListener = Events.on(window, 'orientationchange', debounced);
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    this._removeEventLister();
  },

  _removeEventLister: function _removeEventLister() {
    this._scrollListener && this._scrollListener.off();
    this._resizeListener && this._resizeListener.off();
    this._orientationListener && this._orientationListener.off();
    clearTimeout(this._timer);
  },

  checkIsInView: function checkIsInView() {
    if (!TransitionEvents.support.animationend) {
      return;
    }

    if (this.isMounted()) {
      var isInView = isInViewport(ReactDOM.findDOMNode(this));

      if (isInView && !this.state.inViewport) {
        if (this._timer) {
          clearTimeout(this._timer);
        }

        this._timer = setTimeout(function () {
          this.setState({
            inViewport: true
          });
        }.bind(this), this.props.delay);
      }

      if (this.props.repeat && !isInView) {
        this.setState({
          inViewport: false
        });
      }
    }
  },

  checkRAF: function checkRAF() {
    requestAnimationFrame(this.checkIsInView);
  },

  render: function render() {
    var animation = this.state.inViewport ? this.setClassNamespace('animation-' + this.props.animation) : null;
    var child = React.Children.only(this.props.children);

    // transfer child's props to cloned element
    return cloneElement(child, assign({}, child.props, {
      className: classNames(child.props.className, animation),
      'data-am-scrollspy': 'animation' // style helper
    }));
  }
});

module.exports = ScrollSpy;